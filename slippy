#!/usr/bin/env python3


import slippy_debugging_tools as debug
import sys, re
import slippy_utility as util
import slippy_parse_input as parse
import getopt


class Process:
    def __init__(self):
        self.curr_line        = None
        self.curr_line_num    = None
        self.output_line      = None
        




#------------------------------------------
#                FUNCTIONS
#------------------------------------------

def performQuit(cmd_info, process):
    """
    Exits program at provided address
    """
    number   = cmd_info.single_num
    regex    = cmd_info.single_regexp
    line     = process.curr_line
    line_num = process.curr_line_num
    
    if number != None:
        if line_num == number:
            return True

    elif regex != None:
        if re.search(regex , line):
            return True

    return False



def performPrint(cmd_info, process):
    """
    Prints the current line if it falls within the bounds
    of an address.
    """

    single_num   = cmd_info.single_num
    single_regex = cmd_info.single_regexp
    start_num    = cmd_info.start_num
    start_regex  = cmd_info.start_regexp
    end_num      = cmd_info.end_num
    end_regex    = cmd_info.end_regexp

    line         = process.curr_line
    line_num     = process.curr_line_num
    regex_flag   = cmd_info.regex_found_flag

    #---------'p'---------
    if cmd_info.is_address_found == False:
        process.output_line = line

    #---------'np'---------
    elif single_num != None:
        if single_num == line_num:
            process.output_line = line
        else:
            process.output_line = None

    #---------'/regx/p'---------
    elif single_regex != None:
        if re.search(single_regex, line):
            process.output_line = line
        else:
            process.output_line = None

    #---------'n1,n2p'---------
    elif start_num != None and end_num != None:
        if start_num <= line_num <= end_num:
            process.output_line = line
        else:
            process.output_line = None

    #---------'n,/regx/p'---------
    elif start_num != None and end_regex != None:
        if start_num <= line_num and regex_flag == False :
            process.output_line = line
            if re.search(end_regex, line):
                regex_flag = True
        else:
            process.output_line = None

    #---------'/regx/,np'---------
    elif start_regex != None and end_num != None:
        if re.search(start_regex, line) and regex_flag == False:
            regex_flag = True

        if regex_flag == True and end_num >= line_num:
            process.output_line = line
        else:
            process.output_line = None

    #---------'/regx1/,/regx2/p'---------
    elif start_regex != None and end_regex != None:
        if re.search(start_regex, line) and regex_flag == False:
            regex_flag = True
            
        if regex_flag == True:
            process.output_line = line
        else:
            process.output_line = None

        if  result := re.search(end_regex, line) and regex_flag == True:
            regex_flag = False

       

    cmd_info.regex_found_flag = regex_flag

    return cmd_info, process




def performDelete(cmd_info, process):
    """
    Prints the current line if it falls within the bounds
    of an address.
    """

    single_num   = cmd_info.single_num
    single_regex = cmd_info.single_regexp
    start_num    = cmd_info.start_num
    start_regex  = cmd_info.start_regexp
    end_num      = cmd_info.end_num
    end_regex    = cmd_info.end_regexp

    line         = process.curr_line
    line_num     = process.curr_line_num
    regex_flag   = cmd_info.regex_found_flag

    #---------'d'---------
    if cmd_info.is_address_found == False:
        process.output_line = None

    #---------'nd'---------
    elif single_num != None:
        if single_num == line_num:
            process.output_line = None
        else:
            process.output_line = line

    #---------'/regx/d'---------
    elif single_regex != None:
        if re.search(single_regex, line):
            process.output_line = None
        else:
            process.output_line = line

    #---------'n1,n2d'---------
    elif start_num != None and end_num != None:
        if start_num <= line_num <= end_num:
            process.output_line = None
        else:
            process.output_line = line

    #---------'n,/regx/d'---------
    elif start_num != None and end_regex != None:
        if start_num <= line_num and regex_flag == False :
            process.output_line = None
            if re.search(end_regex, line):
                regex_flag = True
        else:
            process.output_line = line

    #---------'/regx/,nd'---------
    elif start_regex != None and end_num != None:
        if re.search(start_regex, line) and regex_flag == False:
            regex_flag = True

        if regex_flag == True and end_num >= line_num:
            process.output_line = None
        else:
            process.output_line = line

    #---------'/regx1/,/regx2/p'---------
    elif start_regex != None and end_regex != None:
        if re.search(start_regex, line) and regex_flag == False:
            regex_flag = True
            
        if regex_flag == True:
            process.output_line = None
        else:
            process.output_line = line

        if  result := re.search(end_regex, line) and regex_flag == True:
            regex_flag = False

       

    cmd_info.regex_found_flag = regex_flag

    return cmd_info, process




#------------------------------------------
#                  MAIN
#------------------------------------------




argv = sys.argv[1:]

try:
    opts, args = getopt.getopt(argv, "nif")

except getopt.GetoptError:
    print(f'usage: slippy [-i] [-n] [-f <script-file> | <sed-command>] [<files>...]', file=sys.stderr)
    sys.exit(1)

if len(args) != 1:
    util.printError()


input_cmd = args[0]
process   = Process() #holds info of the current command executions
cmd_info  = parse.parseInput(input_cmd)

option_n = False
option_i = False

#check options
for opt, _ in opts:
    if opt == '-i':
        option_i = True
    if opt == '-n':
        option_n = True


line_num = 1
while True:

    line = sys.stdin.readline()
    if line == '':
        break

    #----------update process----------
    process.curr_line = line
    process.curr_line_num = line_num


    #----------Execute Quit----------
    if cmd_info.operation == 'q':
        process.output_line = process.curr_line
        print(process.output_line, end='')
        if performQuit(cmd_info, process):
            sys.exit(0)


    #----------Execute Print----------
    elif cmd_info.operation == 'p':
        process.output_line = process.curr_line

        if option_n == False:
            print(process.output_line, end='')

        cmd_info, process = performPrint(cmd_info, process)

        if process.output_line != None:
            print(process.output_line, end='')


    #----------Execute Delete----------
    elif cmd_info.operation == 'd':
        cmd_info, process = performDelete(cmd_info, process)
        if process.output_line != None and option_n != True:
            print(process.output_line, end='')
        

       



    line_num += 1
















